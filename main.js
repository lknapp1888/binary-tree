(()=>{"use strict";const e=function(e=null,l=null,t=null){this.value=e,this.leftChild=l,this.rightChild=t,this.changeVal=e=>{this.value=e}};e.prototype.updateRightChild=function(e){this.rightChild=e},e.prototype.updateLeftChild=function(e){this.leftChild=e},e.prototype.changeVal=function(e){this.value=e};const l=function(e){if(0!==e.length){if(1===e.length)return e;{const i=l(e.slice(0,Math.floor(e.length/2))),n=l(e.slice(Math.floor(e.length/2),e.length));return t(l(i),l(n))}}},t=function(e,l){let t=[],i=e.length+l.length;for(let n=0;n<i&&(e[0]||l[0]);n++)e[0]<l[0]?t.push(e.shift()):e[0]>l[0]?t.push(l.shift()):e[0]||void 0===l[0]?l[0]||void 0===e[0]?e[0]===l[0]&&t.push(e.shift()):t.push(e.shift()):t.push(l.shift());return t},i=(e,l="",t=!0)=>{null!==e.rightChild&&i(e.rightChild,`${l}${t?"│   ":"    "}`,!1),console.log(`${l}${t?"└── ":"┌── "}${e.value}`),null!==e.leftChild&&i(e.leftChild,`${l}${t?"    ":"│   "}`,!0)},n=function(e,l){return e>l?e:l},h={isNodeBalanced:function(e){const l=this.height(e.leftChild),t=this.height(e.rightChild);return!(l-t<-1||l-t>1)},height:function(e){if(null===e)return 0;const l=this.height(e.leftChild),t=this.height(e.rightChild);return n(l,t)+1}},r=function(t=l(t)){let i=[...new Set(t)];if(0===i.length)return null;const n=(i.length-1+0)/2,h=i[Math.floor(n)];return new e(h,r(i.slice(0,n)),r(i.slice(n+1,i.length)))};document.querySelector(".scriptBtn").addEventListener("click",(()=>{u()}),{once:!0});const o=new function(e){this.tree=r(l(e)),this.queue=[],this.insert=function(e){if(!this.tree.value)return this.tree.value=e;let l=this.tree,t=this.tree;for(;null!==t;){if(e===t.value)return alert("duplicate numbers not allowed");e<t.value?(l=t,t=t.leftChild):(l=t,t=t.rightChild)}l.value<e?l.updateRightChild(r([e])):l.updateLeftChild(r([e]))},this.deleteNode=function(e){let l=this.tree,t=this.tree;for(;null!==t&&e!==t.value;)e<t.value?(l=t,t=t.leftChild):(l=t,t=t.rightChild);return null===t?alert("number does not exist in the tree"):null!==t.leftChild&&null!==t.rightChild?(t.value=this.findSmallestVal(t.rightChild).value,void this.deleteSmallestNode(t,t.rightChild)):null===t.leftChild&&null===t.rightChild?l.leftChild&&l.leftChild.value===e?l.leftChild=null:l.rightChild=null:null===t.leftChild&&null!==t.rightChild?l.leftChild===t?l.leftChild=t.rightChild:l.rightChild=t.rightChild:void 0},this.findSmallestVal=function(e){let l=e;for(;null!==l.leftChild;)l=l.leftChild;return l},this.deleteSmallestNode=function(e,l){let t=e,i=l;if(null===i.leftChild&&t.rightChild===i)return t.rightChild=i.rightChild;if(null===i.leftChild&&t.leftChild===i)return t.leftChild=i.rightChild;for(;null!==i.leftChild;)t=i,i=i.leftChild;console.log(t.leftChild),console.log(i.rightChild),t.leftChild=i.rightChild},this.find=function(e){let l=this.tree;if(e===l.value)return l;for(;null!==l;)if(e<l.value)l=l.leftChild;else if(e>l.value)l=l.rightChild;else if(e===l.value)return l;return null===l?"number is not in tree":l},this.levelOrder=function(e=null,l=this.tree){let t=[l],i=[l.value],n=[l];for(;t.length>0;)null!==t[0].leftChild&&(i.push(t[0].leftChild.value),n.push(t[0].leftChild),t.push(t[0].leftChild)),null!==t[0].rightChild&&(i.push(t[0].rightChild.value),n.push(t[0].rightChild),t.push(t[0].rightChild)),t.shift();return null===e?i:e(n)},this.preorder=function(e=null,l=this.tree){let t=[];const i=function(e,l){null!==e&&(l?l(e):t.push(e.value),i(e.leftChild,l),i(e.rightChild,l))};if(i(l,e),!e)return t},this.postorder=function(e=null,l=this.tree){let t=[];const i=function(e,l){null!==e&&(i(e.leftChild,l),i(e.rightChild,l),l?l(e):t.push(e.value))};if(i(l,e),!e)return t},this.inorder=function(e=null,l=this.tree){let t=[];const i=function(e,l){null!==e&&(i(e.leftChild,l),l?l(e):t.push(e.value),i(e.rightChild,l))};if(i(l,e),!e)return t},this.height=function(e=this.tree){if(null===e)return 0;const l=this.height(e.leftChild),t=this.height(e.rightChild);return n(l,t)+1},this.depth=function(e=this.tree,l=this.tree){let t=0,i=l;const n=e.value;for(;null!==i&&i.value!==n;)n>i.value&&(i=i.rightChild),n<i.value&&(i=i.leftChild),t++;return t},this.isTreeArrBalanced=function(e){for(let l=0;l<e.length;l++)if(!1===h.isNodeBalanced(e[l]))return!1;return!0},this.isTreeBalanced=function(){return this.levelOrder(this.isTreeArrBalanced)},this.rebalance=function(){if(this.isTreeBalanced){const e=this.inorder();this.tree=r(e)}else console.log("tree balanced")}}(function(e,l,t){let i=[];for(let e=0;e<30;e++){let e=Math.floor(30*Math.random());e+=0,i.push(e)}return i}()),u=function(){i(o.tree),console.log(`Is the tree balanced? ${o.isTreeBalanced()}`),console.log(`Level order: ${o.levelOrder()}`),console.log(`preorder: ${o.preorder()}`),console.log(`postorder: ${o.postorder()}`),console.log(`innorder: ${o.inorder()}`),console.log("add several > 100 numbers to inbalance tree"),o.insert(101),o.insert(102),o.insert(103),o.insert(104),o.insert(105),console.log(`Is the tree balanced? ${o.isTreeBalanced()}`),console.log("call the rebalance function"),o.rebalance(),console.log(`Is the tree balanced? ${o.isTreeBalanced()}`),console.log(`Level order: ${o.levelOrder()}`),console.log(`preorder: ${o.preorder()}`),console.log(`postorder: ${o.postorder()}`),console.log(`innorder: ${o.inorder()}`)}})();