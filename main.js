(()=>{"use strict";const t=function(t=null,l=null,e=null){this.value=t,this.leftChild=l,this.rightChild=e,this.changeVal=t=>{this.value=t}};t.prototype.updateRightChild=function(t){this.rightChild=t},t.prototype.updateLeftChild=function(t){this.leftChild=t},t.prototype.changeVal=function(t){this.value=t};const l=function(t){if(0!==t.length){if(1===t.length)return t;{const i=l(t.slice(0,Math.floor(t.length/2))),h=l(t.slice(Math.floor(t.length/2),t.length));return e(l(i),l(h))}}},e=function(t,l){let e=[],i=t.length+l.length;for(let h=0;h<i&&(t[0]||l[0]);h++)t[0]<l[0]?e.push(t.shift()):t[0]>l[0]?e.push(l.shift()):t[0]||void 0===l[0]?l[0]||void 0===t[0]?t[0]===l[0]&&e.push(t.shift()):e.push(t.shift()):e.push(l.shift());return e},i=(t,l="",e=!0)=>{null!==t.rightChild&&i(t.rightChild,`${l}${e?"│   ":"    "}`,!1),console.log(`${l}${e?"└── ":"┌── "}${t.value}`),null!==t.leftChild&&i(t.leftChild,`${l}${e?"    ":"│   "}`,!0)},h=function(t,l){return t>l?t:l},n={isNodeBalanced:function(t){const l=this.height(t.leftChild),e=this.height(t.rightChild);return!(l-e<-1||l-e>1)},height:function(t){if(null===t)return 0;const l=this.height(t.leftChild),e=this.height(t.rightChild);return h(l,e)+1}},r=function(e=l(e)){if(0===e.length)return null;const i=(e.length-1+0)/2,h=e[Math.floor(i)];return new t(h,r(e.slice(0,i)),r(e.slice(i+1,e.length)))},u=new function(t){this.tree=r(l([1,2,3,4,5,6,7,8,9,10])),this.queue=[],this.insert=function(t){if(!this.tree.value)return this.tree.value=t;let l=this.tree,e=this.tree;for(;null!==e;){if(t===e.value)return alert("duplicate numbers not allowed");t<e.value?(l=e,e=e.leftChild):(l=e,e=e.rightChild)}l.value<t?l.updateRightChild(r([t])):l.updateLeftChild(r([t]))},this.deleteNode=function(t){let l=this.tree,e=this.tree;for(;null!==e&&t!==e.value;)t<e.value?(l=e,e=e.leftChild):(l=e,e=e.rightChild);return null===e?alert("number does not exist in the tree"):null!==e.leftChild&&null!==e.rightChild?(e.value=this.findSmallestVal(e.rightChild).value,void this.deleteSmallestNode(e,e.rightChild)):null===e.leftChild&&null===e.rightChild?l.leftChild&&l.leftChild.value===t?l.leftChild=null:l.rightChild=null:null===e.leftChild&&null!==e.rightChild?l.leftChild===e?l.leftChild=e.rightChild:l.rightChild=e.rightChild:void 0},this.findSmallestVal=function(t){let l=t;for(;null!==l.leftChild;)l=l.leftChild;return l},this.deleteSmallestNode=function(t,l){let e=t,i=l;if(null===i.leftChild&&e.rightChild===i)return e.rightChild=i.rightChild;if(null===i.leftChild&&e.leftChild===i)return e.leftChild=i.rightChild;for(;null!==i.leftChild;)e=i,i=i.leftChild;console.log(e.leftChild),console.log(i.rightChild),e.leftChild=i.rightChild},this.find=function(t){let l=this.tree;if(t===l.value)return l;for(;null!==l;)if(t<l.value)l=l.leftChild;else if(t>l.value)l=l.rightChild;else if(t===l.value)return l;return null===l?"number is not in tree":l},this.levelOrder=function(t=null,l=this.tree){let e=[l],i=[l.value],h=[l];for(;e.length>0;)null!==e[0].leftChild&&(i.push(e[0].leftChild.value),h.push(e[0].leftChild),e.push(e[0].leftChild)),null!==e[0].rightChild&&(i.push(e[0].rightChild.value),h.push(e[0].rightChild),e.push(e[0].rightChild)),e.shift();return null===t?i:t(h)},this.preorder=function(t=null,l=this.tree){let e=[];const i=function(t,l){null!==t&&(l?l(t):e.push(t.value),i(t.leftChild,l),i(t.rightChild,l))};if(i(l,t),!t)return e},this.postorder=function(t=null,l=this.tree){let e=[];const i=function(t,l){null!==t&&(i(t.leftChild,l),i(t.rightChild,l),l?l(t):e.push(t.value))};if(i(l,t),!t)return e},this.inorder=function(t=null,l=this.tree){let e=[];const i=function(t,l){null!==t&&(i(t.leftChild,l),l?l(t):e.push(t.value),i(t.rightChild,l))};if(i(l,t),!t)return e},this.height=function(t=this.tree){if(null===t)return 0;const l=this.height(t.leftChild),e=this.height(t.rightChild);return h(l,e)+1},this.depth=function(t=this.tree,l=this.tree){let e=0,i=l;const h=t.value;for(;null!==i&&i.value!==h;)h>i.value&&(i=i.rightChild),h<i.value&&(i=i.leftChild),e++;return e},this.isTreeArrBalanced=function(t){for(let l=0;l<t.length;l++)if(!1===n.isNodeBalanced(t[l]))return!1;return!0},this.isTreeBalanced=function(){return this.levelOrder(this.isTreeArrBalanced)},this.rebalance=function(){if(this.isTreeBalanced){const t=this.inorder();this.tree=r(t)}else console.log("tree balanced")}}([1,2,3,4,5,6,7,8,9,10]);u.insert(11),u.insert(12),i(u.tree),u.rebalance(),i(u.tree)})();